#!/usr/bin/env tclsh
# test_thread_pool.test - Tests for mcp::threadpool module

package require tcltest
namespace import ::tcltest::*

# Source dependencies
set script_dir [file dirname [info script]]
source [file join $script_dir "../../lib/util.tcl"]
source [file join $script_dir "../../lib/log.tcl"]
source [file join $script_dir "../../lib/async.tcl"]
source [file join $script_dir "../../lib/thread_pool.tcl"]

# Suppress log output in tests
::mcp::log::init ERROR [open /dev/null w]

#===========================================================================
# INITIALIZATION TESTS
#===========================================================================

test init-1.0 {Thread pool can be initialized} -body {
    ::mcp::threadpool::init 4 [pwd]
    ::mcp::threadpool::is_initialized
} -result 1 -cleanup {
    ::mcp::threadpool::shutdown
}

test init-1.1 {Worker count must be at least 1} -body {
    ::mcp::threadpool::init 0 [pwd]
} -returnCodes error -match glob -result "*Worker count must be at least 1*" -cleanup {
    catch {::mcp::threadpool::shutdown}
}

test init-1.2 {Worker count cannot exceed 64} -body {
    ::mcp::threadpool::init 100 [pwd]
} -returnCodes error -match glob -result "*Worker count cannot exceed 64*" -cleanup {
    catch {::mcp::threadpool::shutdown}
}

test init-1.3 {worker_count returns correct value} -body {
    ::mcp::threadpool::init 8 [pwd]
    ::mcp::threadpool::worker_count
} -result 8 -cleanup {
    ::mcp::threadpool::shutdown
}

#===========================================================================
# SESSION ROUTING TESTS
#===========================================================================

test routing-2.0 {Sessions are routed to workers} -setup {
    ::mcp::threadpool::init 4 [pwd]
} -body {
    set worker [::mcp::threadpool::get_worker "sess_test_1"]
    expr {$worker >= 0 && $worker < 4}
} -result 1 -cleanup {
    ::mcp::threadpool::shutdown
}

test routing-2.1 {Same session always routes to same worker} -setup {
    ::mcp::threadpool::init 4 [pwd]
} -body {
    set w1 [::mcp::threadpool::get_worker "sess_affinity_test"]
    set w2 [::mcp::threadpool::get_worker "sess_affinity_test"]
    set w3 [::mcp::threadpool::get_worker "sess_affinity_test"]
    expr {$w1 == $w2 && $w2 == $w3}
} -result 1 -cleanup {
    ::mcp::threadpool::shutdown
}

test routing-2.2 {get_worker_index returns -1 for unmapped sessions} -setup {
    ::mcp::threadpool::init 4 [pwd]
} -body {
    # get_worker_index with create_mapping=0 returns -1 for new sessions
    ::mcp::threadpool::get_worker_index "unmapped_session"
} -result -1 -cleanup {
    ::mcp::threadpool::shutdown
}

test routing-2.3 {Different sessions can route to different workers} -setup {
    ::mcp::threadpool::init 4 [pwd]
} -body {
    set workers [list]
    for {set i 0} {$i < 20} {incr i} {
        lappend workers [::mcp::threadpool::get_worker "sess_diverse_$i"]
    }
    # Check that we have more than one unique worker
    set unique [llength [lsort -unique $workers]]
    expr {$unique > 1}
} -result 1 -cleanup {
    ::mcp::threadpool::shutdown
}

test routing-2.4 {remove_session clears mapping} -setup {
    ::mcp::threadpool::init 4 [pwd]
} -body {
    # Create mapping
    ::mcp::threadpool::get_worker "sess_to_remove"
    # Remove it
    ::mcp::threadpool::remove_session "sess_to_remove"
    # Check it's gone (get_worker_index returns -1)
    ::mcp::threadpool::get_worker_index "sess_to_remove"
} -result -1 -cleanup {
    ::mcp::threadpool::shutdown
}

#===========================================================================
# STATISTICS TESTS
#===========================================================================

test stats-3.0 {get_stats returns correct structure} -setup {
    ::mcp::threadpool::init 4 [pwd]
} -body {
    set stats [::mcp::threadpool::get_stats]
    dict exists $stats workers
} -result 1 -cleanup {
    ::mcp::threadpool::shutdown
}

test stats-3.1 {Stats show correct worker count} -setup {
    ::mcp::threadpool::init 4 [pwd]
} -body {
    set stats [::mcp::threadpool::get_stats]
    dict get $stats workers
} -result 4 -cleanup {
    ::mcp::threadpool::shutdown
}

test stats-3.2 {Stats show mode as hybrid} -setup {
    ::mcp::threadpool::init 4 [pwd]
} -body {
    set stats [::mcp::threadpool::get_stats]
    dict get $stats mode
} -result "hybrid-main-thread" -cleanup {
    ::mcp::threadpool::shutdown
}

#===========================================================================
# LIFECYCLE TESTS
#===========================================================================

test lifecycle-4.0 {Shutdown clears all state} -setup {
    ::mcp::threadpool::init 4 [pwd]
    ::mcp::threadpool::get_worker "sess_1"
    ::mcp::threadpool::get_worker "sess_2"
} -body {
    ::mcp::threadpool::shutdown
    ::mcp::threadpool::is_initialized
} -result 0

test lifecycle-4.1 {Can reinitialize after shutdown} -setup {
    ::mcp::threadpool::init 4 [pwd]
    ::mcp::threadpool::shutdown
} -body {
    ::mcp::threadpool::init 8 [pwd]
    ::mcp::threadpool::worker_count
} -result 8 -cleanup {
    ::mcp::threadpool::shutdown
}

#===========================================================================
# ASYNC MODULE TESTS
#===========================================================================

test async-5.0 {Future can be created} -body {
    set fid [::mcp::async::create_future]
    string match "future_*" $fid
} -result 1 -cleanup {
    catch {::mcp::async::cancel $fid}
}

test async-5.1 {Future is pending after creation} -body {
    set fid [::mcp::async::create_future]
    ::mcp::async::is_pending $fid
} -result 1 -cleanup {
    catch {::mcp::async::cancel $fid}
}

test async-5.2 {Future can be completed} -body {
    set fid [::mcp::async::create_future]
    ::mcp::async::complete_future $fid "test_result"
    ::mcp::async::is_pending $fid
} -result 0

test async-5.3 {Future status updates on completion} -body {
    set fid [::mcp::async::create_future]
    ::mcp::async::complete_future $fid "test_result"
    ::mcp::async::get_status $fid
} -result "completed"

test async-5.4 {Cancelled future returns unknown status} -body {
    set fid [::mcp::async::create_future]
    ::mcp::async::cancel $fid
    ::mcp::async::get_status $fid
} -result "unknown"

test async-5.5 {Stats track created futures} -body {
    ::mcp::async::reset
    set fid1 [::mcp::async::create_future]
    set fid2 [::mcp::async::create_future]
    set stats [::mcp::async::get_stats]
    dict get $stats total_created
} -result 2 -cleanup {
    ::mcp::async::reset
}

# Clean up
cleanupTests
